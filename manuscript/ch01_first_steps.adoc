
=  Chapter 1: First Steps

ifndef::already_included_config[]
include::config.adoc[]
endif::[]

:chapter_id: ch1
:imagesdir: ../images/ch01_first_steps

This chapter covers

* What is WebDriver?
* Why choose WebDriver?
* "Hello WebDriver!"


In today's dynamic digital landscape, businesses are under immense pressure to 
innovate rapidly and deliver software updates swiftly to meet evolving market 
demands. Web applications, ranging from simple websites to complex platforms 
developed by large teams, require rigorous testing before release to ensure 
reliability and functionality. Manual testing of these extensive applications 
is increasingly impractical, particularly as organizations strive to accelerate 
time to market.

Adding the ongoing AI revolution, where artificial intelligence streamlines 
various aspects of software development, the ease and speed of crafting software 
have increased. However, the potential for errors persists, emphasizing the 
critical need for on-demand testing. Continuous Integration and Continuous 
Deployment (CI/CD) pipelines enable the instant rollout of online features, 
underscoring the importance of robust automated testing frameworks like Selenium 
WebDriver. These frameworks ensure that software updates undergo thorough 
testing before deployment, maintaining reliability and functionality in 
fast-paced development environments.

Selenium WebDriver stands out as the industry-standard tool for web automation, 
empowering teams to automate testing across diverse browsers and platforms 
efficiently. By automating repetitive testing tasks, WebDriver significantly 
reduces the time needed for testing, enabling teams to focus more on developing 
new features and enhancing user experience.

This chapter introduces Selenium WebDriver's core principles, its pivotal role 
in accelerating software delivery, and practical strategies for integrating it 
into agile CI/CD workflows. It highlights how WebDriver supports high-quality 
software development amidst the complexities of today's AI-driven era and rapid 
deployment cycles. The chapter will rapidly cover the basics, making sure that 
by the end of it you understand the basic architecture can write basic code.

In this chapter we'll introduce WebDriver, what it is, how it works, and reasons 
for choosing it. We'll also briefly talk about some of the tools we used in this 
book, the ones we'd recommend to all developers.


== What is WebDriver?

Selenium WebDriver automates web browsers. It sits in the place of the person 
using a web browser. Like a user, it can open a website, click links, fill in 
forms, and navigate around. It can also examine the page, looking at elements 
on it and making choices based on what is sees.

The most common use case for WebDriver is automated testing. Until recently, 
and in many organizations till this day, in order to run a regression test on 
your website, you'd need to have a set of scripts that would have to be manually 
executed by developers or QAs. Any reports would need to be manually collated 
too. This can be both time-consuming and costly. Instead, WebDriver can be used 
to execute those scripts, and automatically gather reports on how successful 
they were, at the push of a button. Each subsequent execution will be no more 
expensive than the first.

image::before-web-driver.png[title=Before WebDriver]

Long gone are the days when you needed to create one version on your website 
for the pervasive and notoriously standards non-compliant Internet Explorer 6, 
and another for other browsers. While most modern browsers are much more 
consistent in their behavior, the way a web page looks or acts can still greatly 
vary as the number of different browsers, operating system, and platforms in 
common use has increased. You can still have a high-value customer complain that 
they can't access your site. Historically, the only way to mitigate this was to 
have an army of QAs manually test on a variety of different configurations, 
a time-consuming and costly process. WebDriver can run tests on different 
operating systems and different browser configurations, and in a fraction of 
the time of a human being. Not only that, you can use it to run them much more 
consistently and reliably than a manual tester.

Applications and websites provide useful services, but sometimes these are only 
accessible by web pages. Another use case for WebDriver is to make those pages 
accessible to applications via WebDriver. You might have an administration 
application written several years ago and a client or Product Owner has asked 
for some actions on it to be automated. But maybe no one knows where the source 
code is. It might be much easier to use WebDriver to automate this task.

== How WebDriver works

WebDriver works in all major browsers and with all major programming languages. 
How is this possible? Well, WebDriver has several interacting components:

1.  *Web Browser:* Each browser interacts with WebDriver through its respective 
automation mechanisms.
2.  *Browser Plugin or Extension:* This component resides within the browser and 
contains a server that implements the WebDriver W3C Protocol.
3.  *Language Bindings:* WebDriver supports multiple programming languages 
(e.g., Java, Python, JavaScript), enabling developers to make use the W3C 
WebDriver API in their preferred language.

image::web-driver-diagram.png[title=Web driver diagram]

When you initiate code that utilizes WebDriver, it launches the specified 
browser, which then starts its respective WebDriver automation server. 
Through WebDriver's standardized protocol, you can send commands to perform 
actions like clicking links or entering text. Each browser vendor implements 
their own automation server according to the W3C WebDriver Protocol, ensuring 
compatibility and consistent behavior across different browsers.

This standardization means that WebDriver is supported by all major browsers 
and can be used with various programming languages. Integration typically 
involves implementing a client that communicates with the browser's WebDriver 
API, ensuring seamless automation capabilities.

image::safari-extensions.png[title=Safari Extensions panel]

== Why choose WebDriver?

There are numerous automated testing tools available, but Selenium remains the 
leading and most stable choice, with a proven track record spanning almost two 
decades. A vast majority of resources and documentation on the internet 
focus on Selenium, underscoring its dominance in the field.

There are several compelling reasons to opt for Selenium WebDriver:

- *Local and Remote Browser Execution:* Selenium WebDriver can seamlessly run 
browsers both locally and remotely with minimal configuration adjustments.

- *User-Centric Automation:* WebDriver closely mimics user interactions, 
leveraging native events for precise and stable automation.

- *Open Source:* As Open Source Software (OSS), Selenium WebDriver is free to 
use and benefits from a thriving community for support and enhancement.

- *Cross-Platform Compatibility:* Selenium WebDriver supports all major 
operating systems, including OS X, Windows, and Linux, along with mobile 
platforms like Android and iOS.

- *W3C Standardization:* WebDriver is currently the only test automation tool
which is a W3C standard, ensuring long-term support and adoption across the 
industry.

- *WebDriver BiDirectional Protocol:* Selenium is working with browser vendors 
to create the WebDriver BiDirectional Protocol as a means to provide a stable, 
cross-browser API that uses the bidirectional functionality useful for both 
browser automation generally and testing specifically. Before the BiDi procotol, 
users seeking this functionality have had to rely on CDP (Chrome DevTools 
Protocol) which has a numerous limitations.


== What WebDriver cannot do

WebDriver provides a way to control a web browser, but that is all. When you buy 
a new car, you get a manual that will tell you how to operate the radio and how 
to change the oil. But that manual won't tell you the best place to get your car 
serviced, or teach you how to drive. Like driving a car, there are things you 
must do for yourself. Here are some things WebDriver does not do:

* WebDriver doesn’t have the control of the timing of the elements appearing on 
the web page. Some might appear later and you'll need to handle this yourself.
* WebDriver does not know when things have changed on the page, so you can't ask 
it to tell you when things have changed.
* WebDriver doesn't provide many utilities for writing your code. You need to 
write these yourself.
* WebDriver doesn't natively support page elements composed of multiple 
elements, like JavaScript calendars or complex objects built using frontend 
technologies such as React or Angular. Effectively handling these complex 
objects requires additional effort.
* WebDriver does not provide a framework to write your code in. JUnit (5) or 
TestNG are  natural choices.
* WebDriver doesn't manage the browser. For example, you need to clean up after 
you have used it.
* WebDriver won't install or maintain your browsers. You need to do this 
yourself.

We'll cover all these important tasks in this book.

== The history of Selenium

The evolution of Selenium spans a suite of web testing tools: *Selenium IDE*, 
*Selenium RC*, *Selenium WebDriver*, and *Selenium Grid*. Originating from 
ThoughtWorks's Chicago office by Jason Huggins, Selenium Core was initially 
designed to simulate human user actions with Internet Explorer. Unlike 
traditional Record/Replay tools, Selenium Core operated solely with Java, a 
ubiquitous language among developers.

Later, *Shinya Kasatani* extended Selenium with a Firefox plugin called 
*Selenium IDE*, introducing a graphical interface for recording browser 
interactions, appealing to QA testers and analysts lacking programming skills. 
*Selenium Core* transitioned into *Selenium RC* ("Remote Control") and 
*Selenium Grid*, enabling distributed test execution across multiple machines.

*Selenium WebDriver*, developed by *Simon Stewart*, debuted at the 2007 Google 
Test Automation Conference. It introduced a standardized approach via the 
WebDriver API, consolidating the Selenium 2.0 release in 2008. WebDriver's 
adoption soared due to its ability to interact with browsers uniformly through 
a single API, surpassing Selenium RC's capabilities. Selenium RC was 
subsequently deprecated in favor of WebDriver, with migration guides 
facilitating the transition.

In recent years, Selenium has continued to evolve, culminating in Selenium 4, 
which enhances automation capabilities with advanced features and better support 
for modern web standards. WebDriver's adherence to W3C standards ensures 
compatibility and longevity, solidifying its position as the preferred choice for web automation.

[sidebar]
.Why it is called Selenium?
****
Jason Huggins joked about a competitor named Mercury in an email, saying that 
you can cure mercury poisoning by taking selenium supplements. That’s where 
the name Selenium came from.
****


== The tools you need to get started

On top of a computer, access to the Internet, and a development environment, 
you will need some additional pieces of software to get started.

[sidebar]
.Why we use Java in this book
****
While we understand that many developers may not use Java as their primary 
language, we chose it for this book to reach the widest audience possible, 
considering Java's continued popularity as one of the top programming languages.
One of the reasons We chose Java for this book because the original version 
also used Java as its programming language, and we aimed to stay faithful to 
the original while updating it.

The WebDriver API remains consistent across different programming languages. 
The core languages of the web—JavaScript, CSS, and HTML—remain the same 
regardless of the language used for writing tests. If you prefer to use one of 
the many languages supported by WebDriver, such as C#, JavaScript, Ruby, or 
Python, you should find that many of the techniques discussed in this book can 
be applied effectively.
****

=== Java Development Kit (JDK)

As Java is among the most popular and widely used development languages, we 
will be using it throughout this book. Currently, Java 21 is the newest LTS and 
we will use it as our JDK version.

You can check to see if (and which version of) the JDK is already installed 
from a terminal using the `javac` command:

[source,sh]
----------------
$ javac -version
javac 21
----------------

Linux users can install Java using the `yum` or `apt` package managers. Windows 
and OS X users can download it from Oracle at http://www.oracle.com/technetwork/java/javase/downloads/index.html.

=== Apache Maven

Throughout this book we will use the Apache Maven build tool for managing our 
code. The main reason for this is because Maven can manage the many dependencies 
that we need to create an application. You can check to see if you have Maven 
installed from the terminal:

[source,sh]
------------------
$ mvn -version
Apache Maven 3.9.0
------------------

If you do not have it installed, Linux users can install it using their package 
manager (e.g. Apt or Yum), OS X users can install it using the Homebrew package 
manage (http://brew.sh)

For example (on OS-X using Brew):

    brew install maven

Or (on Ubuntu Linux):

    sudo apt-get install maven

Windows users can download it from the Apache Maven website at https://maven.apache.org.

=== Google Chrome

Chromium-based browser are the best supported browser. It is available on every 
platform, it's standards compliant, and has the simple out-of-the-box integration 
with WebDriver. So we will use Chrome browser in this book.

As usual, Linux users can install Chrome using their package manager; otherwise 
you can download Chrome from Chrome.

Later on the book we will look at other browsers such as Firefox or Edge, but 
having Chrome installed now will get you through the first few chapters.

=== Git

You'll need to install Git if you want to check out the source code for this 
book. On OS-X using Brew:

    brew install git

Or on Ubuntu Linux using Apt:

    sudo apt-get install git

If you use Windows, you can download it from <https://git-scm.com/> .

== The test project

As part of this project, we have put all the source code into the Git version 
control system. This contains all the sample code, as well as a small website 
the code runs against.

You can get this by running these commands:

[source,sh]
----------------------------------------------------------------------
git clone https://github.com/selenium-webdriver-book/source.git
cd source
----------------------------------------------------------------------

The project has a built-in web server that can be started by entering the following:

[source,sh]
-------------
mvn jetty:run
-------------

You can view the website it creates at http://localhost:8080/hello-webdriver.html. You should see a page similar to figure <<hello-webdriver>>. This forms the basis of many of the tests in the project, so you'll probably want to keep it running all the time.

[[hello-webdriver]]
image::hello-webdriver.png[title=Hello WebDriver]

When you are done, press `Ctrl+C` to quit the server.

If you want to find examples from the book in the code, look for the package named after the chapter. For example, if you're looking for chapter one's examples, then they can be found in `src/test/java/swb/ch01intro`.

To run all the tests with the book, run the following:

[source,sh]
----
mvn verify
----

Instructions on how to run with different browsers can be found in the `README.md` file.

== “Hello WebDriver!”

Let's look at an example of using WebDriver to automate a basic task, and end up with a working example. A WebDriver automation script usually consists of several operations:

1.  Create a new WebDriver, backed by either a local or remote browser.
2.  Open a web page.
3.  Interact with that page, for example clicking links or entering text.
4.  Check whether the page changes as expected.
5.  Instruct the WebDriver to quit.

Create a directory with this `pom.xml`:

[source,xml]
.pom.xml
------------------------------------------------------------------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns="http://maven.apache.org/POM/4.0.0"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
			http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>hello-webdriver</groupId>
    <artifactId>hello-webdriver</artifactId>
    <version>1.0.0-SNAPSHOT</version>

    <dependencies>
        <dependency>
            <groupId>org.seleniumhq.selenium</groupId>
            <artifactId>selenium-chrome-driver</artifactId> <1>
            <version>LATEST</version> <2>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.3</version>
                <configuration>
                    <source>1.8</source> <3>
                    <target>1.8</target>
                </configuration>
            </plugin>
            <plugin>
                <artifactId>maven-failsafe-plugin</artifactId>
                <version>2.18.1</version>
                <executions>
                    <execution>
                        <goals>
                            <goal>integration-test</goal> <4>
                            <goal>verify</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>

</project>
------------------------------------------------------------------------------------------------------------
<1> You can choose a different browser, e.g. `selenium-firefox-driver` is for the Firefox browser.
<2> Always use the latest version that is available.
<3> Compile using the latest version of Java -- Java 1.8.
<4> Make sure that tests are run using Maven's failsafe plugin.

To start the driver, you'll need a special binary program to start it up. For Chrome, this is called `chromedriver` and can be found at https://sites.google.com/a/chromium.org/chromedriver/downloads. Download it and then save it into the root of the project.

Create `src/test/java/swb/intro/HelloWebDriverIT.java`:

[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch01intro/HelloWebDriverIT.java[HelloWebDriverIT.java]
------------------------------------------------------------------------------------------------------------------------------------------------
package swb.ch01intro;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.openqa.selenium.By; <1>
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.chrome.ChromeDriver;

import static org.junit.Assert.assertEquals;

public class HelloWebDriverIT { <2>

    private WebDriver driver;

    @Before
    public void setUp() throws Exception {
        System.setProperty("webdriver.chrome.driver", "chromedriver"); <3>
        driver = new ChromeDriver(); <4>
    }

    @After
    public void tearDown() throws Exception {
        driver.quit(); <5>
    }

    @Test
    public void helloWebDriver() throws Exception {

        driver.get("http://localhost:8080/hello-webdriver.html"); <6>

        WebElement pageHeading
            = driver.findElement(By.tagName("h1")); <7>

        assertEquals("Hello WebDriver!",
            pageHeading.getText()); <8>
    }
}
------------------------------------------------------------------------------------------------------------------------------------------------
<1> Standard Java imports for WebDriver.
<2> We use the IT suffix for test in this book; this is the Maven convention for integration tests that run using the Failsafe plugin footnote:[https://maven.apache.org/surefire/maven-failsafe-plugin/].
<3> Tell web driver via this system property the location of the driver binary.
<4> Create a new driver which connected to an instance of the Chrome browser.
<5> Make sure that the browser quits when the test finishes.
<6> Open a web page in the browser.
<7> Locate an element on the current page, in this case the page's heading.
<8> Verify that the heading is the value you expect.

You'll need to start up the test project as shown in the previous section before you run the test.  Then, when you run the test, you should see the browser open a page similar to figure <<hello-webdriver>>.

== Summary

* You can use WebDriver to save time and money by automating browser tasks.
* It is especially suited to automated browser testing.
* WebDriver is built around a standard JSON protocol, and that means all major browsers and languages support it.
* There are some great reasons to use WebDriver over manual testing. For example, you can save costs and improve quality at the same time.
* You need some tools to get started. We'll be using Maven and Java in this book.

In the next chapter we will start out on our journey by looking at the first part of any automation script--locating elements on pages.
