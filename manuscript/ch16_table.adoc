= Chapter 16: Examining HTML Tables

:imagesdir: ../images/ch16_table

This chapter covers

* Extracting heading into a list of strings
* Creating domain classes representing the table header and table row
* Validating table using customized result comparator
* Using Java Generics to remove duplicated code

HTML tables are widely used for tabular data presentation. Normally each row in a table represents the same type of data. For example, in the following table, each row is a person. These columns represent an Id, first name, last name and age. And your task to to validate this table to make sure the data are correct.

image::people-table.png[title=An Example of An HTML Table]

Let is tale a loos of the HTML behind this table, there is an `id` attribute for the table tag and we can use it to locate the entire table element.

[source,html]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/main/webapp/people-table.html#L12-L32[people-table.html]
----
<table class="table table-striped" id="users-table">
    <thead>
        <tr>
            <th>Id</th><th>First Name</th><th>Last Name</th><th>Age</th>  <1>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>1</td><td>Eve</td><td>Jackson</td><td>94</td>
        </tr>
        ...
    </tbody>
</table>
----
<1> We assume when we develop a web application with a table, we use TH tag for table header.

From the table, how can we locate all the table cells? In Chapter 2 we introduced a technique related to locate a cell on a table using CssSelector. And in Chapter 12 we introduced an interface `Table` and provided a `SimpleTable` implementation for you to locate a cell by its row number and column number. We believe the technique in Chapter 12 greatly simplifies your tasks of locating cells with known positions on a table.

That technique is good for locating few elements on a table. If you want to do a thorough examination of the table, it is not enough. For example, if you want to validate the information displayed on table is correct and use the technique we learnt from Chapter 12. Since you can only verify each cell individually, the code will be lengthy.

[[long-version]]
[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch16table/tests/NaiveTableIT.java#L25-L68[NaiveTableIT.java]
----
    assertEquals("Id", table.getHeader(1).getText());             <1>
    assertEquals("First Name", table.getHeader(2).getText());
    assertEquals("Last Name", table.getHeader(3).getText());
    assertEquals("Age", table.getHeader(4).getText());

    assertEquals("1", table.getBodyCell(1, 1).getText());        <2>
    assertEquals("Eve", table.getBodyCell(1, 2).getText());
    assertEquals("Jackson", table.getBodyCell(1, 3).getText());
    assertEquals("94", table.getBodyCell(1, 4).getText());
    ... <3>
}
----
<1> Read the header from the table and compare each heading with the expectation
<2> Read each cell and compare with the expectation
<3> The rest of code is omitted


You can see from above listing, this table only has 4 rows and 4 columns of data, the code is already very long. Imaging a table with 100s of rows.

Also, the test will stop at the first error. And if there is any change in the requirements, the data in the table changes accordingly, the test must be changed. Once you have fixed the first error, it may fail at another place, and on and on. You will be exhausted after you fix all the errors for this test!

The test shown above is written in a common seen style in many organization, it is verbose, and violates the single assertion rule in software test. When data changes, you may need to fixed the error one by one and it may be very time consuming to fix all the errors. We just list it here as an anti-pattern for you to be aware of.

[sidebar]
.Single assertion rule
****
Single assertion rule means you should only have one assertion statement in each test. The above code apparently violates that rule and is considered an antipattern. We convert it into a test following single assertion rule, it will be,

[source,java]
----
@Before
public void readTable() {
    browser.get("/people-table.html");
    table = new SimpleTable(browser.await(TABLE));
}

@Test
public void header1ShouldBeId() {
    assertEquals("Id", table.getHeader(1).getText());
}
...
@Test
public void row1Column1ShouldBe1() {
    assertEquals("1", table.getBodyCell(1, 1).getText());
}
...
----

This test looks clean, but its `readTable` method will be executed for each test method. For this table, it is 20 times. And if we use `@BeforeClass` instead of `@Before`, we won't be able to inject the `Browser` needed for the test.
****

It doesn't need to be this way. In this chapter, we are going to introduce some new techniques related to examining a table. And we are going to show you how to design a general class to handle HTML tables to eliminate the amount of repeated code. When requirement changes, you can fix all the errors on one single run.

By the end of this chapter, you will have learnt how to read data from a table into a list of domain objects and use a customized data analyzer to analyze the data and output a meaningful error report with all differences found between the expected and actual results.

== Extracting heading into a list of strings

First, we need to locate the table and its heading. We follow the same locating technique we learned from Chapter 2. We just try to show you how to extract the heading into a list of strings representing each column. By doing this, when we compare the data with the expectation.

We now create a `PersonTable` class to extract the headings,

[[PersonTable]]
[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch16table/v0_5/PersonTable.java#L10-25[PersonTable.java]
----
public class PersonTable {

    private final Element table;

    public PersonTable(Element table) {
        this.table = table;
    }

    public List<String> getHeaders() {   <3>
        List<String> headers = new ArrayList<>();
        for (WebElement th : table.findElements(By.tagName("th"))) {   <1>
            headers.add(th.getText());     <2>
        }
        return headers;
    }
}
----
<1> This logic is based on the assumption we had earlier in the HTML code for the People table.
<2> We use all style for loop to process the collection so we use old method to find elements
<3> In the latter part of this chapter, we are going to use Java 8 Stream to rewrite this method

Some readers may ask, what about the data in the table? Should we use a list of lists? Or an array of strings to represent the rows in the table? Our answer is, yes, you can use both ways. There is a disadvantage of doing these ways. The expectation is not type safe, so you can put a value which is not a number in the place for `id` and `age`. Those errors can only be detected when you run the tests. In the following example, you made a mistake of using "b" instead of "1", you can only detect this mistake when you run the test.

[source,java]
----
    assertEquals("b", table.getBodyCell(1, 1).getText());
----

When you run it, it fails with assertion error.

[source,java]
----
org.junit.ComparisonFailure:
Expected :b
Actual   :1
 <Click to see difference>
----

So we are going to show you another way of extracting data. And you can see this kind of error will be caught during compile time. In order to do that, we need to introduce a domain class first.

== Creating domain classes representing table rows

We are going to introduce a domain class to represent the people table we are trying to automate, it has id, first name, last name and age as properties.

=== Creating domain object super class

Instead of using array of strings, we can create an entity class to represent the data on each row. For the particular table example, we will create a `Person` class. Unlike the Java class you might create for the production code, you may not need to provide getters for this class. But it does need at least an `equals` method for comparison and a `toString` method for debugging purposes. Now you can see by overriding the `equals` method in `Person` class, we effectively encapsulate the logic to compare two instance of `Person` class. We can create one instance and use it as the expectation and read the data row on one HTML table and create another instance, then we can use the `Assert.assertEquals` method from junit testing framework. While it will be cumbersome to use junit if you just extract the data into list of strings, the expectation data will not be type safe as shown before .

In tests, We need to compare the equality of other domain objects and output debugging messages for developer to analyze the cause of the failure. So we need to provide some customized `equals`, `hashCode` and `toString` method to those classes as well. In order not to repeat those methods in every classes we create, we introduce this `DomainBase` class as the super class for those domain classes, so they don't need to provide these methods if the can use these default ones in `DomainBase` class,

[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/framework/domain/DomainBase.java#L8-L25[DomainBase.java]
----
public abstract class DomainBase {   <1>

    @Override
    public boolean equals(Object other) {  <2>
        return EqualsBuilder.reflectionEquals(this, other);  <3>
    }

    @Override
    public int hashCode() {  <4>
        return HashCodeBuilder.reflectionHashCode(this);   <5>
    }

    @Override
    public String toString() {   <6>
        return ToStringBuilder.reflectionToString(this);  <7>
    }

}
----
<1> We make it abstract so don't want people to create an instance of this class
<2> Override the `equals` method from `Object` class
<3> Use `EqualsBuilder` to check whether two instances are equal
<4> Override the `hashCode` method from `Object` class
<5> Use `HashCodeBuilder` to calculate the hash code of this object
<6> Override the `toString` method from `Object` class
<7> Use `ToStringBuilder` to output the content of this object

Any class extends DomainBase inherits these three methods. But if they don't meet your needs, you still can override them in the subclass, we are going to override one method when we create subclasses, `toString` to illustrate this.

[sidebar]
.Apache Commons Library
****
We use Apache Commons library here to for those method. If you are not familiar with it, you can find out more from the project website,

https://commons.apache.org/
****

=== Creating domain class

Now we create `Person` class and it extends `DomainBase` class. Since we are not satisfied with the `toString` method from `DomainBase` class, we override it in `Person` class to output different format.

[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch16table/domain/Person.java#L3-L22[Person.java]
----
public class Person extends DomainBase {
    private final int id;
    private final String firstName;
    private final String lastName;
    private final int age;

    public Person(int id, String firstName,String lastName, int age) {...} <3>

    @Override
    public String toString() {                     <1>
        return "new Person(" + id +
                ",\"" + firstName + "\",\"" +
                lastName + "\"," + age   + ")\n";    <2>
    }
}
----
<1> We can define how to output the person, this is just one example and it is not prescriptive but we do have our reason to do this way
<2> The reason toString is coded this way is that we can copy from the output of test run and use it to modify the expectation
<3> Standard constructor

When you calling the `toString` method of `Person` object, it will output the way how it is created. This can be illustrated in the following test,

[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch16table/domain/PersonTest.java#L3-L22[PersonTest.java]
----
private Person person = new Person(1, "John", "Doe", 44);

@Test
public void testToString() throws Exception {
    assertEquals("new Person(1, \"John\", \"Doe\", 44)\n", person.toString());
    System.out.println(person);
}
----

You can see it prints,

[source,java]
----
new Person(1, "John", "Doe", 44)
----

This output can be copied and used to change the expectation when test fails. We will apply this in next section of this chapter.

Once you create this `Person` domain class, you can use it to map each row in the table into an instance of this class. We will show you this technique in the following section.

=== Extracting rows into a list of domain objects

We are going to add a *row mapper* as an constant of the `PersonTable` class we introduced earlier in Listing <<PersonTable>>. The responsibility of row mapper is to map each row on the table to an instance of the `Person` class. So we use the `Function` interface which takes a list of `Element`, where the first element is the first cell on that row, and second element is the second cell, and so on. And, it creates a instance of the `Person` class. We use pre-java 8 style to create an anonymous inner class of `Function`, implements its `apply` method here as a starting point. The code is a bit verbose. We will use Java 8 style later, and the code will be cleaner. So you can compare them.

[[PersonTable]]
[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch16table/v0_8/PersonTable.java#L28-56[PersonTable.java]
----
public static final Function<List<Element>, Person> MAPPER_NON_JAVA_8   <1>
    = new Function<List<Element>, Person>() {      <4>
    @Override
    public Person apply(List<Element> cells) {    <5>
        return new Person(          <2>
            Integer.parseInt(cells.get(0).getText()),  <6>
            cells.get(1).getText(),                    <7>
            cells.get(2).getText(),                    <8>
            Integer.parseInt(cells.get(3).getText())   <3>
        );
   }
};
----
<1> `MAPPER_NON_JAVA_8` will map the data in each row into a `Person` class
<2> Create an instance of `Person` class using those parameters
<3> Use the fourth element as the fourth parameter
<4> Create anonymous class of `Function<List<Element>, Person>` type
<5> Provide implementation on the fly
<6> Convert the first element into Integer and pass as the first parameter
<7> Use the second element as the second parameter
<8> Use the third element as the third parameter

And add `getRow` method to extract the table rows using the mapper `MAPPER_NON_JAVA_8`.

[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch16table/v0_8/PersonTable.java#L28-56[PersonTable.java]
----
public List<Person> getRows() {     <2>
    List<Person> rows = new ArrayList<>();  <1>

    for (WebElement tr : table.findElement(By.tagName("tbody"))   <3>
        .findElements(By.tagName("tr"))) {   <4>

        List<Element> cells = new ArrayList<>();
        for (WebElement cell : tr.findElements(By.tagName("td"))) {  <5>
            cells.add(new Element(cell));   <6>
        }
        rows.add(MAPPER_NON_JAVA_8.apply(cells));  <7>
    }
    return rows;
}
----
<1> Create a list of `Person`
<2> `getRow` will return a list of those instances of `Person` class
<3> Find <tbody> element on the <table> element
<4> Find all <tr> elements inside the <tbody> element and loop though it
<5> Loop through the list of <td> elements found on each <tr> element
<6> Create an instance of `Element` class and add to a list of `cells`
<7> Use `MAPPER_NON_JAVA_8` mapper to convert the list of cells of `Element` into a `Person` object and add to a list of `Person` objects

`PersonTable` class extracts a list of instances of the `Person` class from the HTML table. And we are going to verify the results in the next section.

We can move `MAPPER_NON_JAVA_8` in Listing <<PersonTable>> out of `PersonTable` class into its own place, such as an enum constant,

[[PersonMapper]]
[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch16table/mapper/PersonMapper.java#L9-L22[PersonMapper.java]
----
public enum PersonMapper implements Function<List<Element>, Person> {

    MAPPER_NON_JAVA_8 {
        @Override
        public Person apply(List<Element> cells) {
            return new Person(...);
        }
    }
}
----

And you can delete the `MAPPER_NON_JAVA_8` variable from `PersonTable` and just import this enum constant, it works exactly same as before. That way, the test is laid out cleanly with the intention, which is not buried in details.

Once we read the table contents into a list of domain object using mapper, we can validate them using some customized result comparator to generate a report shown the different between the expected results and what is actually displayed on the table. So we can find out all the differences between what should be displayed on table and what is actually displayed on table in a very easy to digest format. It helps the developers to understand the problem better and make it easier to make changes to the failed tests and make them work.

== Validating a table using customized result comparator

Test purpose of test is the make sure the application behave correctly. But it will be nice if the test can help developer to diagnose the problem and make it easier to fix the failed tests.

Next we are going to introduce a technique to make debugging a failed test easier.

=== Technique 48: Defining Customized Result Comparator to output detailed difference report

Often, people write tests which fails at the first failed assertion, just as illustrated by listing <<long-version>>. There is a fundamental drawback with that approach. When things go wrong, you can only fix one problem on each run since each time you can only see one failed assertion. Thus it can be extremely time consuming to fix failed tests, especially when you need to navigate a couple of pages before making an assertion. Often people blame Selenium for that. It is not a problem with Selenium but with the way the tests are written.

This technique will show you how to make the test easier to debug.

==== Problem

Tests are hard to debug due to limited diagnostic output. And after you fix one problem, you will get another problem. This goes on and on.

==== Solution

One approach is to find all possible errors so we can fix them together.

We are going to create a `PersonTableContents` class to output all the differences between expected result and actual contents.  This class has two responsibilities,

* Compare it with an actual result to see whether they are same
* Calculate the difference between the expected and actual result.

The `describeDiff` method of `PersonTableContents` class will find out what is missing in the actual result as well as what in the actual result is not expected. It extends DomainBase and inherits the three methods from DomainBase.

[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch16table/v1/PersonTableContents.java#L9-L41[PersonTableContents.java]
----
public String describeDiff(PersonTableContents other) {   <1>
    return diffHeaders(other)
        + diff(this.rows, other.rows, "expected rows not found: ")   <3>
        + diff(other.rows, this.rows, "unexpected rows appeared: ");  <4>
}

public String diffHeaders(PersonTableContents other) {  <2>
    StringBuilder diff = new StringBuilder();
    if (!headers.equals(other.headers)) {
        diff.append("headers differ ")
            .append(headers).append(" vs ")
            .append(other.headers).append("\n");
    }
    return diff.toString();
}

public <T> String diff(List<T> rows1, List<T> rows2, String s) {   <7>
    List<T> diff = new ArrayList<>(rows1);
    diff.removeAll(rows2);   <5>

    return diff.isEmpty() ? "" : s + diff + "\n";  <6>
}
----
<1> This method is used to output the contents so junit can compare expected result with actual result.
<2> Generate the difference of headers
<3> Find out the rows in expected but not in actual
<4> Find out the rows in actual but not in expected
<5> Removing the elements in the second parameter rows2, the whatever left is the ones only in the first parameters row1
<6> Format the message using the third parameter when there is difference
<7> This method is parameterized

Then we can modify `PersonTable` class to add the method to create `TableContents`, it just creates an instance of `PersonTableContents` using header and rows,

[source,java]
----
public PersonTableContents getContents() {
   return new PersonTableContents(getHeaders(), getRows());
}
----

And we can write a `PersonTableIT` to verify the contents are correct,

[[test-failed]]
[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch16table/tests/PersonTable_v1_IT.java#L55-L75[PersonTable_v1_IT.java]
----
public static final PersonTableContents OUTDATED_EXPECTED =   <4>
    new PersonTableContents(
        Arrays.asList("Id", "First Name", "Last Name", "Age"),
        Arrays.asList(
            new Person(1, "Eve", "Jackson", 94)
            , new Person(2, "John", "Doe", 80)   <3>
            , new Person(4, "Jill", "Smith", 50)
            , new Person(5, "Jack", "Clyde", 78)   <1>
        )
    );

@Test
@Ignore("You can remove this to run it and check the output")   <2>
public void testReadFromPersonTableButFailed() {

    PersonTable table = new PersonTable(browser.await(TABLE));  <7>

    PersonTableContents actual = table.getContents();   <5>

    assertEquals(OUTDATED_EXPECTED.describeDiff(actual), OUTDATED_EXPECTED, actual);  <6>
}
----
<1> This row actually doesn't exist, so the test will fail, let us run it and observe the output
<2> You can remove this line to run the test
<3> There is a reason why the comma start from the beginning of the second line
<4> To create an expected table contents for the test
<5> Get the actual table contents from HTML page
<6> Compare the actual with the expected and output the difference information
<7> Create `PersonTable` using <table> element

When you run the test, it will fail and you can observe the following output on the console

image::test-failure.png[title=Failed test with detailed reason for failure.]

And after you click the link of `<Click to see difference>`, the following window will be popped up to tell you the difference between expected result and actual result.

[[difference]]
image::difference.png[title=Difference between expected result and actual result.]

Also, if you made the same mistake of using `"b"` instead of `1`,

[source,java]
----
new Person(1, "Eve", "Jackson", 94)
----

it would cause a compilation error, as in the following figure.

image::CompileError.png[title=Compilation error caused by type mismatch detected by Intellij IDEA]

All IDEs such as Intellij, Eclipse and NetBeans can detect mistake earlier and save you time.

==== Discussion

While you work on a project, likely things will change soon and often, you end up changing the test a lot. This technique can help you to improve the productivity of changing the test, as illustrated in Figure <<difference>>, it is obvious to know the difference between the expected results and actual result. With a more detailed test report, you will have all information to fix the test quicker than writing a test which fails at the first assertion failure.

Also we explained why the `toString` method is like following,

[source,java]
----
@Override
public String toString() {
    return "new Person(" + id + ", \"" + firstName + "\", \"" +
            lastName + "\", " + points + ")\n";
}
----

You can see the message in the error report can be copied as code. Once you have verified that the following result is correct,

[source,java]
----
, new Person(3, "Adam", "Johnson", 67)
----

you can copy it to replace the old expectation `OUTDATED_EXPECTED` from Listing <<test-failed>>.

[source,java]
----
, new Person(5, "Jack", "Clyde", 78)
----

This can save you some effort from typing the new code in the the test.

== Remove duplicated code

In real life project, there will be tables for different data types. For example, not only will you have a table of people, but you will have a table of cities as well, as shown in the following figure. footnote:[In case you are wondering why these cities are listed here, they are actually all the cities one of the author have lived in the past.]

image::city-table.png[title=Another Example of An HTML Table]

We are gong to show you a solution without using Java Generics first. You can see, even we use object oriented principle and introduce an abstract class and remove obvious duplicated code, we can't remove the code differ only in types. After you finish reading this section, you will have a clear understanding why sometimes we need to use generics.

To validate this city table, we can follow the same approach we validate people table. Just like we create a `Person` class for people table, we create a `City` class for city table.

[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch16table/domain/City.java#L5-L22[City.java]
----
public class City extends DomainBase {
    private final int id;
    private final String name;
    private final String stateName;

    public City(int id, String name, String stateName) {...} <3>

    @Override
    public String toString() {    <1>
        return "new City(\"" + id +          <2>
                "\",\"" + name + "\",\"" + stateName  + ")\n";
    }
}
----
<1> Override the `toString` from `DomainBase` class
<2> The purpose of this method is also generating code
<3> Standard constructor

And here is the class diagram of `Person` and `City` classes, they both override the `toString` method of `DomainBase` super class to have their own format.

image::person.png[title=Class diagram of `City` and `Person`]

You can create a `CityMapper`, which does not need to be an enum constant as the `PersonMapper`, we can use a lambda expression to create a `public final static` variable in `CityMapper` class instead. We just give an alternative here and we think they both are good design so you can choose one of them.

[[CityMapper]]
[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch16table/mapper/CityMapper.java#L9-L16[CityMapper.java]
----
public class CityMapper {

    public final static Function<List<Element>, City> MAPPER_LAMBDA =   <1>
        cells ->       <2>
            new City(   <3>
                Integer.parseInt(cells.get(0).getText()),  <4>
                cells.get(1).getText(),    <5>
                cells.get(2).getText());   <6>
}
----
<1> `MAPPER_LAMBDA` constant to map a list of `Element` objects into a `City` object
<2> Use lambda expression to create the `MAPPER_LAMBDA` of type `Function<List<Element>, City>`
<3> Create an instance of `City` class using those parameters
<4> Convert the first element into Integer and pass as the first parameter
<5> Use the second element as the second parameter
<6> Use the third element as the third parameter

Next we are about to create a `CityTable` class using this mapper, which is very similar to `PersonTable` class. But since the `getHeaders` method is same for both `PersonTable` and `CityTable`, so we are going to introduce a technique to remove the duplicates. Due to the limitation of that technique, the duplicate can only be removed partially.

=== Technique 49: Using abstract class to partially remove duplicated code

We need to create `CityTable` class to extract the headers and rows information on city table page.

==== Problem

If we create `CityTable` class by copying `PersonTable` class, `getHeaders` method is same for both `PersonTable` and `CityTable`.

==== Solution

we can create an abstract class with `getHeaders` method and delete the one in `PersonTable`.

[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch16table/v2/AbstractTable.java#L10-L24[AbstractTable.java]
----
public abstract class AbstractTable {
    protected Element table;              <1>

    public AbstractTable(Element table) {
        this.table = table;
    }

    public List<String> getHeaders() {          <2>
        List<String> headers = new ArrayList<>();
        for (WebElement th : table.findElements(By.tagName("th"))) {
            headers.add(th.getText());
        }
        return headers;
    }
}
----
<1> It needs to be a `protected` variable in order for its subclasses to access it.
<2> This method is deleted from `PersonTable` class

Then we can have `CityTable` class extending `AbstractTable` class so we don't need to have the `getHeader` repeating here.

[[CityTable]]
[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch16table/v2/CityTable.java#L13-L49[CityTable.java]
----
public List<City> getRows() {   <4>
    List<City> rows = new ArrayList<>();   <2>

    for (WebElement tr : table.findElement(By.tagName("tbody"))   <1>
        .findElements(By.tagName("tr"))) {

        List<Element> cells = new ArrayList<>();
        for (WebElement cell : tr.findElements(By.tagName("td"))) {
            cells.add(new Element(cell));
        }
        rows.add(MAPPER_LAMBDA.apply(cells));   <5>
    }
    return rows;
}

public CityTableContents getContents() {
    return new CityTableContents(getHeaders(), getRows());   <3>
}
----
<1> This for loop statement is almost identical to the one inside the same method in `PersonTable`, with difference in mapper and the type of the `rows` variable
<2> It creates a list for `City` objects
<3> Create `CityTableContents` object for the content of the table,
<4> This method is almost same as the one in `PersonTable` except it returns a `List<City>`
<5> Create a `City` object from `cells` and add to `rows`

As well as a `CityTableContents` class, also similar to `PersonTableContents` class. We follow the same approach as the `AbstractTable` class and create an `AnstractTableContents` class and move two methods originally in `PersonTableContents` over, as following,

[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch16table/v2/AbstractTableContents.java#L8-L32[AbstractTableContents.java]
----
public class AbstractTableContents extends DomainBase {

    private final List<String> headers;

    public AbstractTableContents(List<String> headers) {
        this.headers = headers;
    }

    public String diffHeaders(AbstractTableContents other) {
        StringBuilder diff = new StringBuilder();
        if (!headers.equals(other.headers)) {
            diff.append("headers differ ")
                .append(headers).append(" vs ")
                .append(other.headers).append("\n");
        }
        return diff.toString();
    }

    public <T> String diff(List<T> rows1, List<T> rows2, String s) {
        List<T> diff = new ArrayList<>(rows1);
        diff.removeAll(rows2);

        return diff.isEmpty() ? "" : s + diff + "\n";
    }
}
----

And have `CityTableContents` class extending it, so `diifHeaders` and `diff` methods don't need to be repeated in `CityTableContents` class,

[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch16table/v2/CityTableContents.java#L7-L21[CityTableContents.java]
----
public String describeDiff(CityTableContents other) {  <1>
    return diffHeader(other)
        + diff(this.rows, other.rows, "expected rows not found: ")
        + diff(other.rows, this.rows, "unexpected rows appeared: ");
}
----
<1> The code in this method is almost same as `PersonTableContents`, the only different is the parameter `CityTableContents`

And you can run the following test to verify the result. You need to comment out the line starting with `@Ignore` annotation to activate this test, otherwise it is ignored by junit test framework,

[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch16table/tests/CityTable_v1_IT.java#L63-83[CityTable_v1_IT.java]
----
private static final CityTableContents OUTDATED_EXPECTED =
    new CityTableContents(
      Arrays.asList("Id", "City Name", "State Name"),
      Arrays.asList(
          new City(1, "Xian", "Shanxi")
          , new City(2, "Guangzhou", "Guangdong")
          , new City(3, "Shaoguan", "Guangdong")
          , new City(11, "Dallas", "Texas")
      )
  );

@Test
@Ignore("You can remove this to run it and check the output")  <1>
public void failedToReadFromTable() {

    CityTable table = new CityTable(browser.await(TABLE));

    CityTableContents actual = table.getContents();

    assertEquals(OUTDATED_EXPECTED.describeDiff(actual), OUTDATED_EXPECTED, actual);
}
----
<1> You can delete this line to run this test

This is a failed test and you will have enough information to working on the fix of the tests. The reason we provide failed tests here is to illustrate the benefit of having customized comparison and error reporting in the tests.

==== Discussion

You can see, by using inheritance, we can only partially remove the duplicated code, `getHeaders` is in `AbstractTable` class so both `CityTable` and `PersonTable` inherit it from `AbstractTable`. They both have `getRows` method defined individually, even those two methods are quite similar. However, we can't have a single method to handle both table, person and city tables, since `Person` and `City` are too different types.

Here is the class diagram with both sets of classes for city and people table,

image::tables.png[title=Class diagram of classes for city and people table]

Probably you already noticed that there are many similarities between the two sets of the classes and code for `getRows` in two table classes and `describeDiff` in two table contents are not exactly but looks very similar. And we can't use inheritance to remove the duplicates.

The duplicate can be removed. We are going to show you how to use Java Generics to remove the duplicated code. But if you are an experienced developer, probably you will just start with generics. We create these two sets of classes is to educate less experienced developers how to refactor the tests.

=== Technique 50: Using Java Generics to remove duplicated code

We are going to show you how to use Java Generics to reduce duplicated code.

==== Problem

You noticed that there are many similarities between the two sets of the classes and most codes are duplicated, even you tried to use inheritance but there is some duplicate code which can't be reduced using inheritance.

==== Solution

We will use Generics introduced from Java 5. Instead of creating `PersonTable`, `CityTable` and so on, we just create one `Table<T>` class. And when we want to use it, we pass in a generics parameter to the `Table` class, such as `Table<Person>`, `Table<City>`.

We are going to add a *row mapper* into the constructor of a `Table<T>` class to replace both `PersonTable` and `CityTable` classes. What this row mapper does is to map each row on the table to an instance of the `T` class we pass in. For `Table<Person>`, it will map to a list of `Person`, but for `Table<City>`, it will map to a list of `City`.

[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch16table/v3/Table.java#L11-L42[Table.java]
----
public class Table<T> {  <1>

    private final Element table;
    private final Function<List<Element>, T> rowMapper;  <2>

    public Table(Element table, Function<List<Element>, T> rowMapper) {
        this.table = table;
        this.rowMapper = rowMapper;
    }

    private Stream<String> getHeaders() {...}

    private Stream<T> getRows() {...}   <3>

    public TableContents<T> getContents() {     <4>
        return new TableContents<>(getHeaders(), getRows());
    }
}
----
<1> `rowMapper` will map the data in each row into a domain class dominated by the type parameter
<2> The mapper maps the list of `td` element into type `T`
<3> Find all `th` elements and return a `Stream<T>`
<4> Create a `TableContents<T>` instance


We use Java 8 feature in this class, and if you are not comfortable with the syntax, please refer the sidebar for more information.

[sidebar]
.Stream API from Java 8
****
We use Java 8 Stream API in `getHeader` and `getRows` methods. If you
are not familiar with it, you can find out more from Java website,

https://docs.oracle.com/javase/8/docs/api/index.html

and click the java.util.stream link for that package.

If you are seriously considering learning Java 8, we highly recommend
the book Java 8 in Action from Manning

https://www.manning.com/books/java-8-in-action

The code is actually used Stream API to map the table row into domain object `T`,
[source,java]
----
private List<String> getHeaders() {
    return table.findElements(TH)
        .map(Element::getText)
        .collect(Collectors.toList());
}

private List<T> getRows() {
    return table.await(TBODY)
        .findElements(TR)
        .map(tr ->
           rowMapper.apply(
              tr.findElements(TD).collect(Collectors.toList())
           )
        ).collect(toList());
}
----

If you are not familiar with this style, it is fine. You can use pre-Java 8 style to work with Generics and remove the duplicated code. Generics came in Java 5.
****

Same as we use `Table<T>` to replace `PersonTable` and `CityTable`, we will use `TableContents<T>` to replace `PersonTableContents` and `CityTableContents`.

[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch16table/v3/TableContents.java#L9-L41[TableContents.java]
----
public class TableContents<T> extends DomainBase {

    private final List<String> headers;
    private final List<T> rows;

    public TableContents(List<String> headers, List<T> rows) {
        this.headers = headers;
        this.rows = rows;
    }

    public String describeDiff(TableContents<T> other) {...} <2>

    private String diffHeaders(TableContents<T> other) {...} <3>

    private String diff(List<T> rows1, List<T> rows2, String s) {...} <1>
}
----
<1> This method is same as the one in `CityTableContents` except it doesn't need the type parameter <T> since it is on class level
<2> The method body is same as the `describeDiff` method in `PersonTableContents`
<3> The method body is same as the `diffHeaders` method in `AbstractTableContents`

To see how can you pass in a mapper to the constructor of `Table` class, and we can use the `MAPPER_LAMBDA` variable in `CityMapper` class from Listing <<CityMapper>>.

[source,java]
----
public final static Function<List<Element>, City> MAPPER_LAMBDA =
    cells ->
        new City(
            Integer.parseInt(cells.get(0).getText()),
            cells.get(1).getText(),
            cells.get(2).getText());
----

Now we invoke its constructor with an instance of <table> element found by calling `browser.await(TABLE) and `MAPPER_LAMBDA` to construct an instance of `Table<City>`.

[source,java]
----
Table<City> table = new Table<>(browser.await(TABLE), MAPPER_LAMBDA);
----

Or if you use Java 8, you can have the following concise form by using Lambda expression to create a `rowMapper` and use it as the second parameter to create an instance of `Table` class.

[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch16table/tests/CityTable_v2_IT.java#L53-66[CityTable_v2_IT.java]
----
@Test
public void testReadFromTableJava8() {

    Table<City> table = new Table<>(browser.await(TABLE), <1>
        cells ->  <2>
            new City(Integer.parseInt(cells.get(0).getText()),  <3>
                cells.get(1).getText(),
                cells.get(2).getText())
    );

    TableContents<City> actual = table.getContents();

    assertEquals(EXPECTED.describeDiff(actual), EXPECTED, actual);
}
----
<1> The instance of `Element` class representing the HTML table element
<2> This is a lambda expression to create an instance of `Function<List<Element>, City>` and use it as the second parameter to create `Table` object
<3> The purpose of lambda expression is exactly same as variable `MAPPER_NON_JAVA_8`,  to convert a list of `Element` into an instance of `City` class

And you can use the same `Table<T>` class to automate the people table as well, just pass a different mapper as the second parameter, you can use the `MAPPER_NON_JAVA_8` enum from Listing <<PersonMapper>>,

[source,java]
----
MAPPER_NON_JAVA_8 {
    @Override
    public Person apply(List<Element> cells) {
        return new Person(...);
    }
}
----

And we invoke the constructor with an instance of <table> element found by calling `browser.await(TABLE) and `MAPPER_NON_JAVA_8` to construct an instance of `Table<Person>`.

[source,java]
----
Table<Person> table = new Table<>(browser.await(TABLE), MAPPER_NON_JAVA_8);
----

Here are the reduced classes for city and people table, and if you add more domain to the project, you don't need to add new table classes.

image::table.png[title=Class diagram of generic classes for city and people table]

With the help from Generics, you turn the two abstract classes into two concrete classes with type parameter.

==== Discussion

Now you can see, we only need one `Table<T>` class one `TableContents<T>` class to handle HTML tables with different data types, such as `Person` and `City`, and other data type you use in your projects. The different mapping logic is managed by the row mapper classes we create for the data types. Generics is a powerful way to reduce duplication and you will find it useful.

We spent a whole chapter on table because table is a very complex HTML element on web page. This chapter just gives you an idea what can be done when validating a table, but we don't think the `Table` and `TableContents` classes can be applied to any tables out there in the wild so we don't put it under the `framework` package.

When you validate a table, you will definitely find the techniques from this chapter are useful. The customized comparator can also be applied to other kind of tests as well, it is not Selenium WebDriver specific. Generics is also very commonly used in Java programming language.

== Summary

* You can identify the properties of table and define a correspondent class as the place holder for the properties
* You can use a general purposed `Table` class to take a function as parameter to locate a table and its rows and columns
* Validate the contents of the table and generate output for all the differences on one run to save the time of running the tests over and over again by using the failure on first error approach.
* Use Generics to remove duplicated code.
* Use toString method to generate usable code.

// AC - added transition to next chapter

In next two chapters, we are going to automate jQuery datepicker and extract a framework and use it to automate some popular datepickers such ReactJS, Bootstrap, Material-UI and JsDatePick.
